(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{352:function(e,v,t){"use strict";t.r(v);var _=t(14),i=Object(_.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[e._v("React 出现的意义（原因）？")]),e._v(" "),v("p",[e._v("传统的网页开发是使用命令式（例如当表单项填写值不对，提交时需要错误提示的场景，需要手动控制提交失败、修改错误信息的展示与否、错误信息的内容等。）的编程方式来进行页面交互，即 ui 的变化由开发者调用原生 api 进行修改，这种方式会非常繁琐，同时对于复杂业务，当业务发生变化时，开发者需要将代码全部过一遍以防出现漏掉的部分，效率非常低，且容易造成 bug。而 React 将它变成了声明式的，开发者只需要考虑业务中有哪些状态就能将业务都表现出来即可，怎样根据状态渲染出 dom 交给了 react。（将开发者的关注点由 dom 变更变成了数据驱动）")]),e._v(" "),v("p",[e._v("为什么会有 diff 算法？")]),e._v(" "),v("p",[e._v("鉴于 react 是依赖 vdom 树渲染、更新页面的，每次更新状态都会重新生成 vdom 树，如果每次都全量替换性能显然很差，所以需要通过 diff 算法找出最少的更新内容来进行优化")]),e._v(" "),v("p",[e._v("react16 后为什么引入了 fiber？")]),e._v(" "),v("p",[e._v("在 react 的一次更新中，会经历生成新的 dom 树，diff 算法进行对比，更新内容 commit，更新 dom 这几个过程，原来的 vdom 数据结构这个过程是无法中断的，当组件更新过多的时候可能会比较慢阻碍了浏览器的渲染，就是会造成页面的卡顿。为了解决这个问题在 react16 后，vdom 都被转化为了 fiber 节点，它在保存了 vdom 的信息的基础上，还保存了父节点、子节点、兄弟节点的引用，是一个链表结构，这样 react 就能中断更新的过程（分片更新），优先去执行用户触发的优先级更高的工作，并在完成用户的工作后重新找到中断的地方继续做更新操作，让用户感知不到卡顿。")]),e._v(" "),v("p",[e._v("react 的 diff 算法？")]),e._v(" "),v("ol",[v("li",[e._v("16 版本之前：react 采用了 vdom 的方式来描述 dom 结构，当组件更新的时候会生成一颗新的 vdom 树，然后会将新旧两棵树进行递归对比\n"),v("ol",[v("li",[e._v("当节点类型不同，会直接删除旧的子树，生成使用新的子树")]),e._v(" "),v("li",[e._v("当 react 元素类型相同，属性发生了变化，会保留 dom 节点，仅对比及更新有改变的属性，然后继续递归子节点")]),e._v(" "),v("li",[e._v("当组件元素相同时，组件实例会保持不变，会更新该组件实例的 props、state 保证与最新的元素一致")]),e._v(" "),v("li",[e._v("对于子元素列表，会检查节点的 key，根据 key 决定节点的新增、删除和复用，提高更新效率")])])]),e._v(" "),v("li",[e._v("16 版本之后：引入 fiber，对于节点类型不同等情况 diff 算法的执行和 16 之前一致，对于子元素列表，由于数据结构变为了链表所以发生了一些变化\n"),v("ol",[v("li",[e._v("对新旧列表使用循环的方式进行遍历，节点相同则进行复用，直到遇到不同的节点，记录节点的位置")]),e._v(" "),v("li",[e._v("如果新列表被遍历完了，那么旧列表后续的节点删除即可")]),e._v(" "),v("li",[e._v("如果新列表没遍历完，就列表遍历完了，则新列表没遍历完的都是新增的节点直接新增")]),e._v(" "),v("li",[e._v("如果都没有遍历完，则将就列表的元素节点，以 key 为键，以节点为值，生成一个 map，然后循环遍历新节点剩余的部分，如果能在 map 中找到则复用，如果找不到则视为新节点，遍历完成后清空旧列表没有被复用的节点就完成了")])])])]),e._v(" "),v("p",[e._v("react 的 setState 是异步的吗？")]),e._v(" "),v("p",[e._v("分为两种情况：")]),e._v(" "),v("ol",[v("li",[e._v("如果在生命周期或合成事件中调用，react 会将状态放到更新队列，并在合适的时机合并之后批量更新，防止状态频繁变化导致频繁的重渲染")]),e._v(" "),v("li",[e._v("如果是 setTimeout、setInterval、eventListener 里边，这些 api 不是 react 能控制的，为了保证渲染正确，每次都会立即更新状态")])]),e._v(" "),v("p",[e._v("react 17 和 18 的新特性？")]),e._v(" "),v("p",[e._v("17：")]),e._v(" "),v("ol",[v("li",[e._v("在严格模式时，React 会对每个组件返回两次渲染，以便观察一些意想不到的结果，在 17 中去掉了一次渲染的控制台日志，以便让日志更容易阅读")])]),e._v(" "),v("p",[e._v("18：")]),e._v(" "),v("ol",[v("li",[e._v("将所有事件（原生 js 事件、promise、setTimeout、setInterval）都进行批处理，即多次 setState 会被合并为一次")]),e._v(" "),v("li",[e._v("引入了新的 root api（ReactDom.createRoot），支持 new concurrent renderer（并发模式的渲染）")]),e._v(" "),v("li",[e._v("去掉了对 ie 的支持，新特性全部基于现代浏览器")]),e._v(" "),v("li",[e._v("flushSync：批量更新是一个破坏性的更新，如果想退出批量更新就是用 flushSync，它也能让 react 立即同步更新 DOM，在它后面操作 dom，dom 会是最新的 dom 结构")]),e._v(" "),v("li",[e._v("在 17 中，空组件只能返回 null，在 18 中支持 null 和 undefined 的返回")]),e._v(" "),v("li",[e._v("18 取消了 17 严格模式去掉一次渲染日志的限制，第二次渲染会以浅灰色出现在控制台")]),e._v(" "),v("li",[e._v("Suspense 不再需要 fallback 捕获")]),e._v(" "),v("li",[e._v("支持 useId：在服务器和客户端生成相同的唯一 id，避免 hydrating 的不兼容")]),e._v(" "),v("li",[e._v("useDeferredValue: 可以让一个 state 延迟生效，只有当前没有紧急更新时，该值才会变为最新值。useDeferredValue 和 startTransition 一样，都是标记了一次非紧急更新")]),e._v(" "),v("li",[e._v("useSyncExternalStore")]),e._v(" "),v("li",[e._v("useInsertionEffect：这个 Hooks 只建议 css-in-js 库来使用。 这个 Hooks 执行时机在 DOM 生成之后，useLayoutEffect 生效之前，一般用于提前注入 "),v("style")])])])}),[],!1,null,null,null);v.default=i.exports}}]);