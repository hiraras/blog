(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{359:function(e,l,v){"use strict";v.r(l);var _=v(14),t=Object(_.a)({},(function(){var e=this,l=e._self._c;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h2",{attrs:{id:"webpack-构建流程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#webpack-构建流程"}},[e._v("#")]),e._v(" webpack 构建流程")]),e._v(" "),l("ol",[l("li",[e._v("初始化参数：将配置文件和 shell 语句中读取的参数合并，得出最终参数")]),e._v(" "),l("li",[e._v("开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译")]),e._v(" "),l("li",[e._v("确定入口：根据配置中的 entry 找出所有的入口文件")]),e._v(" "),l("li",[e._v("编译模块：从入口文件触发，调用所有配置的 "),l("code",[e._v("Loader")]),e._v(" 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理")]),e._v(" "),l("li",[e._v("完成模块编译：在经过第 4 步使用 "),l("code",[e._v("Loader")]),e._v(" 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系")]),e._v(" "),l("li",[e._v("输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 chunk，再把每个 chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会")]),e._v(" "),l("li",[e._v("输出完成：再确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统")])]),e._v(" "),l("p",[e._v("在以上过程中，webpack 会在特定的时间点广播出特定的事件，插件在监听到对应的事件后会执行特定的逻辑，并且插件可以调用 webpack 提供的 api 改变 webpack 的运行结果")]),e._v(" "),l("p",[e._v("简单说：")]),e._v(" "),l("ul",[l("li",[e._v("初始化：启动构建，读取与合并配置参数，加载 plugin，实例化 compiler")]),e._v(" "),l("li",[e._v("编译：从 entry 触发，针对每个 module 串行调用对应 loader 去翻译文件的内容，再找到该 module 依赖的 module，递归地进行编译处理")]),e._v(" "),l("li",[e._v("输出：将编译后的 module 组合成 chunk，将 chunk 转化成文件，输出到配置的文件系统中")])])])}),[],!1,null,null,null);l.default=t.exports}}]);