# 事件循环（旧）

## 为什么会有事件循环？

js 是一个单线程的语言，所以无法实现异步任务机制，故浏览器通过实现事件循环机制来做到

js 有一个宏队列和微队列；一个宏任务加上微队列里的所有方法构成一个周期，不断循环执行这个周期就是所谓的事件循环

## 执行顺序

先执行宏队列里的第一个方法，完成后再去清空当前微队列里有的微任务，当微队列任务清空后，再执行第二个宏任务，在这个宏任务中如果微队列又增加了新的微任务（微任务执行的时候创建了新的微任务，那它也会在本轮执行），则再次清空微队列，最后再往后执行下一个宏任务，以此类推

## 分类

宏任务：

1. script 代码块，其中 new Promise()的参数函数会立即执行，async 函数 如果执行了，在第一个 await 之前的代码也会立即执行
2. setTimeout、setInterval
3. dom 监听
4. UI rendering
5. ajax

微任务：

1. promise.then 的回调
2. queueMicrotask,接受一个函数，并放入当前微任务队列
3. Mutation Observer API

# 浏览器的进程模型

## 何为进程？

程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程

每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意（程序之间隔离，这样即使某个程序崩溃，也不会影响到其他程序）

## 何为线程？

有了进程后，就可以运行程序的代码了

运行代码的"人"称之为"线程"

一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程（如果主线程结束了，整个程序就结束了）。

如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。

## 浏览器有哪些进程和线程？

浏览器是一个多进程多线程的应用程序

浏览器内部工作极其复杂

为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程（主要有浏览器进程、网络进程、渲染进程）。

1. 浏览器进程

主要负责界面显示（前进后退、收藏栏、扩展程序等）、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。最开始只有浏览器进程被启动，启动后它会去启动其他子进程（网络进程、渲染进程等）

2. 网络进程

负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务

3. 渲染进程

渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码

默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。

## 渲染主线程是如何工作的？

渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：

- 解析 HTML
- 解析 CSS
- 计算样式
- 布局
- 处理图层
- 每秒把页面画 60 次
- 执行全局 JS 代码
- 执行事件处理函数
- 执行计时器的回调函数
- 其他

思考：为什么渲染进程不适用多个线程来处理这些事情？

一个想法：有点像 react 中一个页面中使用了多个 useEffect，这些处理不同任务的 effect，很多还涉及了各自的异步状态（不同 effect 可能还相互有依赖关系），最终要拼出一个成品页面。需要程序员对状态的脉络管理非常清楚，经常还需要写一些判断条件进行某些 effect 的管理。在浏览器包含上述这么多任务的情况下，如果启用多线程各自处理，代码复杂度会非常高，非常难以管理，因此采用了单个线程。

要处理这么多的任务，主线程又有了一个新的难题：如何调度任务？

例如：

- 我正在执行一个 js 函数，执行到一半的时候用户点击了按钮，我该去立即执行点击事件的处理啊函数吗？
- 我正在执行一个 js 函数，执行到一半的时候某个计时器到达了时间，我该去立即去执行它的回调吗？
- ...

渲染主线程想出了一个绝妙的注意来处理这个问题：排队（提供一个规则，让开发者自己按照需要进行处理）

1. 最开始的时候，渲染主线程会进入一个无限循环
2. 每一次循环会检查消息队列中是否有任务存在。如果有就取出第一个任务执行，执行完一个后进入下一次循环；如果没有则进入休眠状态。
3. 其他所有线程（包括其他进程的线程，浏览器线程可以监听用户交互<比如点击事件，然后就将点击的回调放入消息队列>）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务。

整个过程，被称之为事件循环（也叫消息循环）

## 若干解释

### 何为异步？

代码在执行过程中，会遇到一些无法立即处理的任务，比如：

- 计时完成后需要执行的任务 -- setTimeout、setInterval（计时线程实现）
- 网络通信完成后需要执行的任务 -- XHR、Fetch（网络进程实现？）
- 用户操作后需要执行的任务 -- addEventListener（浏览器线程实现？）

以上也能看出，浏览器的工作模式是：每个标签页维护自己的渲染主线程，渲染主线程中有个消息队列，执行了一些代码后，会将任务分发给其他线程/进程，等其他线程/进程处理完任务后，将回调放到消息队列，由消息队列按照排队的规则执行

如果让渲染主线程等待这些任务的时机到达，就会导致主线程长期处于"阻塞"的状态，从而导致浏览器"卡死"

### JS 为何会阻碍渲染？

因为 js 执行和 ui 的渲染都发生在渲染主线程，js 任务没有执行完毕，自然就会阻碍渲染任务的执行

### 任务有优先级吗？

任务没有优先级，在消息队列中先进先出

但消息队列是有优先级的

过去就是宏任务和微任务

**随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法**，根据 W3C 的最新解释：

- 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。
- 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行。

在目前 chrome 的实现中，至少包含了下面的队列：

- 延时队列：用于存放计时器到达后的回调任务，优先级为中
- 交互队列：用于存放用户操作后产生的事件处理人物，优先级为高
- 微队列：用于存放需要最快执行的任务，优先级为最高

添加任务到微队列的主要方式是使用 Promise、MutationObserver

## 问题

1. 浏览器对一些任务为何需要异步的方式来处理

浏览器有很多类型的很多任务（渲染、用户操作、计时器、js 代码等等），如果所有代码都采用同步的方式，那一个长任务势必会阻碍所有其他任务的执行，表现为浏览器的卡顿

2. 事件循环是用来处理异步的吗？

应该说事件循环可以用来处理异步，事件循环是浏览器执行内部事件调度的一个机制，这个机制配合回调正好能用来实现异步，但它的作用为"调度"，而不是说为异步而设计的 **这是一开始的理解，实际上如果把渲染任务、用户交互的任务都囊括在异步那其实这个问题的答案是肯定的**

## 面试题

1. 如何理解 JS 异步？

**JS 是一门单线程语言，运行在浏览器的渲染主线程，渲染主线程只有一个。**

而渲染主线程承担了许多任务，包括解析 HTML、解析 CSS、运行 js，渲染页面等

如果采用同步的方式，当执行一个长时间的任务（例如计时任务），势必会导致主线程的阻塞，从而导致其他任务无法得到执行。这样，一方面会导致繁忙的主线程白白消耗时间，另一方面导致页面无法更新，给用户造成卡死现象。

所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，例如计时器、网络请求、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务，转而去执行其他任务。当其他线程完成时，**将事先传递的回调函数包装成任务**，加入到消息队列的末尾排队，等待主线程调度执行

在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。

2. 阐述一下 JS 的事件循环

事件循环又叫做消息循环，是浏览器渲染主线程的工作方式

在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可

过去把消息队列简单的分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。

根据 W3C 官方解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务，但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。

```js
// 一个说明渲染主线程中有多个队列的例子

<button id="btn" onclick="clickHandle">
  click
</button>;

function delay(duration) {
  const start = Date.now();
  while (Date.now() - start < duration) {}
}

function addTimeoutDelay() {
  console.log("添加计时器延迟");
  setTimeout(() => {
    console.log("执行计时器");
  }, 0);
  delay(2000); // 延迟保证了计时器回调一定被添加到了延时队列
}

function addInteractionDelay() {
  console.log("添加渲染延迟");
  document.getElementById("btn").click();
  delay(2000); // 延迟保证了点击事件一定被添加到了交互队列
}

function clickHandle() {
  console.log("执行点击");
}

(function () {
  addTimeoutDelay();
  addInteractionDelay();
})();
```

3. JS 中的计时器能做到精确计时吗？为什么？

不行，原因如下：

1. 计算机硬件没有原子钟，无法做到精确计时
2. 操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差
3. 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差
4. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差。

## 总结

单线程是异步产生的原因，事件循环是异步的实现方式
