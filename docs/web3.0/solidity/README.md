# web3.0 solidity

是一个全新的语言，可以用来创建、编译、发布 web3.0 的合约

开发工具：

[Remix](https://remix.ethereum.org/)

合约文件以大驼峰文件名命名，.sol 为扩展名，有一些规范

1. 扩展名为 .sol
2. 文件名采用大驼峰命名法
3. 文件名和合约名保持一致

```js
// SPDX-License-Identifier: MIT
// 或
// SPDX-License-Identifier: GPL-3.0
```

上述代码，是 solidity 源代码中的一个注释，用于指定智能合约的许可证信息。通常位于代码的开头，目的是明确合约的授权和许可条件，以确保开发者和用户知道如何合法地使用合约

MIT 许可证是一种开源软件许可证，允许任何人自由使用、修改和分发合约的代码，只要他们保留原始许可证文本并提供相关许可声明

```js
pragma solidity ^0.8.7;
```

上述代码指定了 solidity 编译器的版本要求，^符号和 npm 版本类似

还可以指定版本范围

```
pragma solidity >=0.8.0 <0.9.0;
```

**在 solidity 中每句代码都需要分号结尾**

## 定义合约（有点类似定义类）

```js
contract HelloWorld {
    // 状态变量
    string public name;

    constructor() {
        name = "emina";
    }

    function sayName() public view returns(string memory) {
        return name;
    }

    function changeName(string memory _name) public {
        name = _name;
    }
}
```

view: 用于声明一个函数是一个“查看函数”或“只读函数”。查看函数是指那些不修改区块链状态的函数，他们只是读取数据并返回结果

作用和好处：

1. 状态不变性： view 关键词确保函数在执行期间不会修改合约的状态。这意味着在调用查看函数后，合约的状态（包括成员变量）不会被更改，从而保持了合约的不变性。
2. 无需支付 gas 费用： 由于查看函数不修改状态，它们不需要支付 gas 费用。因此，调用查看函数不会触发交易，也不会消耗以太币。
3. 本地执行： 查看函数可以在本地执行，而不需要向以太坊网络发出交易请求。这使得查看函数在客户端应用程序中非常有用，因为它们可以立即返回结果，而不需要等待交易确认。
4. 与其他合约交互： 由于查看函数不会修改状态，它们可以安全地与其他合约进行交互，而不会引发状态变化。

pure: 用于表示函数是纯函数，通常用于执行数学运算或将输入参数转换为某种形式，而不涉及区块链状态

纯函数有以下特点

1. 这个函数不会读取合约的状态变量，也不会修改合约的状态，它仅依赖于函数参数，返回一个计算结果
2. 纯函数不能访问 this 和 msg 对象，也不能发送交易或调用其他合约

pure 和 view 的主要区别：

1. pure 用于纯函数，不读取状态、也不修改状态，通常用于执行计算
2. view 用于视图函数，可以读取状态但不修改状态，通常用于查询数据

全局变量

| 名称                                         | 功能                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| blockhash(uint blockNumber) returns(bytes32) | 获取给定区块的哈希值 - 只适用于 256 最近区块，不包含当前区块 |
| block.coinbase(address payable)              | 获取当前区块矿工的地址                                       |

可见性修饰符，声明状态变量如果不加修饰符，默认为 internal

1. public: 所有合约与账号都可以调用
2. private: 只有在定义该函数的合约可以调用
3. internal: 当前合约或者继承该合约的，类似 java 里面的 protected 关键字
4. external: 只有其他合约或者账号可以调用，定义该函数的合约不能调用，除非使用 this

## 函数

可以定义在合约内也可以在合约外

## 错误

assert(bool condition): 用于在合约执行期间检查条件是否满足，如果条件不满足，则终止合约的执行，并**回滚**状态。确保代码在遇到异常情况是停止执行，从而防止不一致的状态或意外行为

需要注意的是，因为触发 assert 将导致合约执行失败，并且会消耗所有的 gas。因此，它通常用于检查不应该发生的情况，例如编程错误或约束条件的违反。如果你希望处理一些正常的错误情况并继续执行合约，可以考虑使用 require 和 revert

require(bool condition, errorMessage: string): 也是用于检查条件是否满足，第二个参数还能对错误进行描述。
如果条件不满足，则终止合约的执行，并**回滚**状态。第二个参数要想显示中文提示，需要添加 unicode 标识符

```js
require(1 > 0, unicode"发生了错误：xxxxx");
```

和 assert 的区别

1. require 通常用于检查函数的前提条件或用户提供的输入是否有效。它是一种通用的错误检查机制，用于确保合约在执行期间的输入和状态满足特定的条件;assert 通常用于检测合约内部的错误或不应该发生的情况。它用于捕获程序中的不一致性或错误状态。如果 assert 失败，这通常意味着存在合约编程错误
2. require 失败时，消耗的 gas 会退还给调用者，因为它是一种合理的错误检查;assert 失败时，消耗的 gas 不会退还给调用者，因为它通常表示合约内部的严重错误
3. require 不会导致合约的其他函数停止执行，而 assert 会停止当前合约执行的一切操作。

由于这些区别，通常建议使用 require 来执行输入验证和前提条件检查，以及确保合约在接收到无效输入时能够正常处理。而 assert 则更适合用于检测内部错误和不应该发生的情况，以提高合约的稳定性和安全性。

revert 也是用来处理错误的，有两种使用方式

1. 当做函数来调用

```js
revert("xxxxxxxx");
```

2. 抛出自定义错误

```js
error MyError(string message)

if (condition) {
    revert MyError("xxxxxxx")
}
```
