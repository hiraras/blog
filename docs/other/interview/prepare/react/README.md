React 出现的意义（原因）？

传统的网页开发是使用命令式（例如当表单项填写值不对，提交时需要错误提示的场景，需要手动控制提交失败、修改错误信息的展示与否、错误信息的内容等。）的编程方式来进行页面交互，即 ui 的变化由开发者调用原生 api 进行修改，这种方式会非常繁琐，同时对于复杂业务，当业务发生变化时，开发者需要将代码全部过一遍以防出现漏掉的部分，效率非常低，且容易造成 bug。而 React 将它变成了声明式的，开发者只需要考虑业务中有哪些状态就能将业务都表现出来即可，怎样根据状态渲染出 dom 交给了 react。（将开发者的关注点由 dom 变更变成了数据驱动）

为什么会有 diff 算法？

鉴于 react 是依赖 vdom 树渲染、更新页面的，每次更新状态都会重新生成 vdom 树，如果每次都全量替换性能显然很差，所以需要通过 diff 算法找出最少的更新内容来进行优化

react16 后为什么引入了 fiber？

在 react 的一次更新中，会经历生成新的 dom 树，diff 算法进行对比，更新内容 commit，更新 dom 这几个过程，原来的 vdom 数据结构这个过程是无法中断的，当组件更新过多的时候可能会比较慢阻碍了浏览器的渲染，就是会造成页面的卡顿。为了解决这个问题在 react16 后，vdom 都被转化为了 fiber 节点，它在保存了 vdom 的信息的基础上，还保存了父节点、子节点、兄弟节点的引用，是一个链表结构，这样 react 就能中断更新的过程（分片更新），优先去执行用户触发的优先级更高的工作，并在完成用户的工作后重新找到中断的地方继续做更新操作，让用户感知不到卡顿。

react 的 diff 算法？

1. 16 版本之前：react 采用了 vdom 的方式来描述 dom 结构，当组件更新的时候会生成一颗新的 vdom 树，然后会将新旧两棵树进行递归对比
   1. 当节点类型不同，会直接删除旧的子树，生成使用新的子树
   2. 当 react 元素类型相同，属性发生了变化，会保留 dom 节点，仅对比及更新有改变的属性，然后继续递归子节点
   3. 当组件元素相同时，组件实例会保持不变，会更新该组件实例的 props、state 保证与最新的元素一致
   4. 对于子元素列表，会检查节点的 key，根据 key 决定节点的新增、删除和复用，提高更新效率
2. 16 版本之后：引入 fiber，对于节点类型不同等情况 diff 算法的执行和 16 之前一致，对于子元素列表，由于数据结构变为了链表所以发生了一些变化
   1. 对新旧列表使用循环的方式进行遍历，节点相同则进行复用，直到遇到不同的节点，记录节点的位置
   2. 如果新列表被遍历完了，那么旧列表后续的节点删除即可
   3. 如果新列表没遍历完，就列表遍历完了，则新列表没遍历完的都是新增的节点直接新增
   4. 如果都没有遍历完，则将就列表的元素节点，以 key 为键，以节点为值，生成一个 map，然后循环遍历新节点剩余的部分，如果能在 map 中找到则复用，如果找不到则视为新节点，遍历完成后清空旧列表没有被复用的节点就完成了

react 的 setState 是异步的吗？

分为两种情况：

1. 如果在生命周期或合成事件中调用，react 会将状态放到更新队列，并在合适的时机合并之后批量更新，防止状态频繁变化导致频繁的重渲染
2. 如果是 setTimeout、setInterval、eventListener 里边，这些 api 不是 react 能控制的，为了保证渲染正确，每次都会立即更新状态

react 17 和 18 的新特性？

17：

1. 在严格模式时，React 会对每个组件返回两次渲染，以便观察一些意想不到的结果，在 17 中去掉了一次渲染的控制台日志，以便让日志更容易阅读

18：

1. 将所有事件（原生 js 事件、promise、setTimeout、setInterval）都进行批处理，即多次 setState 会被合并为一次
2. 引入了新的 root api（ReactDom.createRoot），支持 new concurrent renderer（并发模式的渲染）
3. 去掉了对 ie 的支持，新特性全部基于现代浏览器
4. flushSync：批量更新是一个破坏性的更新，如果想退出批量更新就是用 flushSync，它也能让 react 立即同步更新 DOM，在它后面操作 dom，dom 会是最新的 dom 结构
5. 在 17 中，空组件只能返回 null，在 18 中支持 null 和 undefined 的返回
6. 18 取消了 17 严格模式去掉一次渲染日志的限制，第二次渲染会以浅灰色出现在控制台
7. Suspense 不再需要 fallback 捕获
8. 支持 useId：在服务器和客户端生成相同的唯一 id，避免 hydrating 的不兼容
9. useDeferredValue: 可以让一个 state 延迟生效，只有当前没有紧急更新时，该值才会变为最新值。useDeferredValue 和 startTransition 一样，都是标记了一次非紧急更新
10. useSyncExternalStore
11. useInsertionEffect：这个 Hooks 只建议 css-in-js 库来使用。 这个 Hooks 执行时机在 DOM 生成之后，useLayoutEffect 生效之前，一般用于提前注入 <style> 脚本。
12. Concurrent Mode：18 的大部分功能都是基于 CM 实现的
13. startTransition：Transitions 是 React 18 引入的一个全新的并发特性。它允许你将标记更新作为一个 transitions（过渡），这会告诉 React 它们可以被中断执行，并避免回到已经可见内容的 Suspense 降级方案。
14. useTransition：用来跟踪 transition 状态

React 组件为什么不能返回多个元素？

1. React 组件最后会被编译为 render 函数，函数的返回值只能是 1 个
2. react 的虚拟 dom 是一个树状结构，数的根节点只能是 1 个，如果有多个，无法确认是在哪棵树上更新

什么是合成事件？

React 基于浏览器的事件机制实现了一套自身的事件机制，它符合 W3C 规范，包括事件触发、事件冒泡、事件捕获、事件合成和事件派发等

动机：

1. 在底层磨平不同浏览器的差异，保证了兼容性问题
2. 把握了事件机制的主动权，实现了对所有事件的中心化控制
3. React 引入事件池避免垃圾回收，在事件池中获取或释放事件对象，避免频繁的创建和销毁

和原生 dom 事件的区别？

虽然合成事件不是原生 dom 事件，但它包含了原生 dom 事件的引用，可以通过 e.nativeEvent 访问

react 的数据流为什么是单向的？

一个父组件的状态可能被多个子组件所引用，如果数据流是双向的，父组件的状态发生改变时，难以知道是哪个子组件造成的状态修改，使得状态管理变的混乱所以采用了单向的数据流

react 的组件类型有哪些？

1. 根据创建方法分为 class 组件和函数式组件
2. 根据功能分为 ui 组件（又叫纯组件，不包含 state）和容器组件（容器组件负责管理数据和逻辑）

抽取组件以什么为标准？

1. 经常使用到的 ui 模块（也能保证 ui 的统一）
2. 拥有相似逻辑的抽成高阶组件（配置也可以属于这个范围）
3. 具有复杂代码结构的，根据模块抽成小组件（提高代码可读性）
4. 对具有许多公共配置的组件进行抽取（公共组件、chart），可以将一些不那么重要的配置代码隐藏到内部，将开发者关注点集中到更关键的地方，同时确保风格统一

组件之间是怎么通信的？

1. 父子组件之间：采用单向数据流的方式，即从父级组件传递给子组件，子组件想要修改父组件的状态，通过父组件传递的修改方法来修改
2. 兄弟组件之间：将状态提升到最近的、公共的父组件中，分别传递给子组件
3. 层级比较深的组件之间：项目比较简单可以使用 Context，项目比较复杂，或这种情况比较多可以引入全局的状态管理如 redux

除了上面提到的方法，还有什么手段能实现组件通信？

1. 使用 localStorage|sessionStorage
2. 使用 web worker
3. 使用 ref 引用组件实例
4. 使用 eventBus

react 的 fiber 结构是什么？为什么会出现？

在 react15 以前 react 的组件更新创建虚拟 dom 和 diff 的过程是不可中断的，如果需要更新的组件树层级非常深，在 diff 过程会非常占用浏览器的线程。而浏览器执行 js 的线程和渲染 dom 的线程是互斥的，也就是在同一时间内，要么执行 js 代码，要么渲染页面，如果 js 运行过程太长就会造成页面卡顿，基于以上原因 react16 将原来数组结构的虚拟 dom 改成了 fiber 的数据结构，基于这种数据结构可以实现更新过程异步可中断更新

jsx 是什么？

jsx 是 javascript 的**语法扩展**，可以让你在 js 文件中书写类似 html 的标签

什么时候会采用 useReducer？

1. 有多个彼此有相关的状态时，考虑将它们写到一起
2. 组件之间传递的状态和方法较多，使用 useReducer 减少传递的属性和方法

react 有哪些优化手段？

1. 利用 shouldComponentUpdate，减少不必要的重渲染
2. 在这基础上使用 React.PureComponent，它是默认实现了一个 shouldComponentUpdate，对 state 和 props 进行浅比较
3. 函数组件使用 React.memo 进行缓存，它是个高阶组件
4. 懒加载一些不是立即需要的组件（Suspense 和 React.lazy）
5. 在 ajax、setTimeout 等 react 无法状态批量合并的地方，通过合并为一个对象或 unstable_batchedUpdates 方式进行批量合并，18 版本中不需要了
6. 正确使用 key

封装过哪些 hooks？

1. 针对 ajax 请求的 hook
2. 一些公共逻辑的封装
3. 副作用有关的优化, 例如发出一个比较耗时的请求，但在它结束之前组件被卸载了，就可能会产生，卸载的组件调用设置状态的 api 的情况

```js
const useSafeEffect = (fn: Function) => {
  const [data, setData] = useState(null);
  let flag = true;
  useEffect(() => {
    (async () => {
      try {
        const data = await fn();
        if (flag) {
          setData(data);
        }
      } catch (e: any) {
        console.log("error");
      }
    })();
    return () => {
      flag = false;
    };
  }, []);
  return { data };
};
```

React 中的事件优先级是怎么确定的？

1. 事件优先级：按照用户事件的交互紧急程度，划分的优先级，在注册阶段确定

- 离散事件：click、keydown，focus 等，优先级为 0
- 用户阻塞事件：drag、scroll、mouseover 等，特点是连续触发，阻塞渲染，优先级为 1
- 连续事件：canplay、error、audio 标签的 timeupdate 和 canplay，优先级最高，为 2

2. 更新优先级：事件导致 React 产生的更新对象的优先级

3. 任务优先级：产生更新对象之后，react 去执行一个更新任务，这个任务所持有的优先级

4. 调度优先级：Scheduler 根据 react 更新任务生成一个调度任务，这个调度任务所持有的优先级

它们之间是递进的关系。

事件优先级由事件本身决定，更新优先级由事件计算得出，然后放到 root.pendingLanes，任务优先级来自 root.pendingLanes 中最紧急的那些 lanes 对应的优先级，调度优先级根据任务优先级获取。几种优先级环环相扣，保证了高优任务的优先执行。

forceUpdate？

调用后会跳过 shouldComponentUpdate 的检查（但不会跳过子组件的），然后使用最新的 state 对象作为新的状态执行 render，可以用在以下两种情况

1. 你知道深层的状态属性发生改变（在状态上直接修改元素，然后调用 forceUpdate 时组件强制更新）
2. 状态之外的变量发生改变，同时想要更新组件（例如定义在组件外层的一个变量）
